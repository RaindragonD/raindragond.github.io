{"componentChunkName":"component---src-templates-post-item-js","path":"/distributed-system/2020-7-16-distributed-system-raft/","result":{"data":{"site":{"siteMetadata":{"title":"NowhereLog"}},"markdownRemark":{"id":"ee5411b9-4cca-5c86-b6ff-9d7e74934482","excerpt":"This post lays down the motivations and challenges for distributed systems and introduces an approach to fault-tolerant distributed systems using Raft…","html":"<blockquote>\n<p>This post lays down the motivations and challenges for distributed systems and introduces an approach to fault-tolerant distributed systems using Raft. </p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#distributed-systems-why-and-how\">Distributed Systems: Why and How</a></li>\n<li><a href=\"#fault-tolerance\">Fault-tolerance</a></li>\n<li><a href=\"#raft\">Raft</a></li>\n<li><a href=\"#a-framework-of-distributed-service-using-raft\">A framework of distributed service using Raft</a></li>\n<li><a href=\"#references\">References</a></li>\n</ul>\n</div>\n<h1 id=\"distributed-systems-why-and-how\" style=\"position:relative;\"><a href=\"#distributed-systems-why-and-how\" aria-label=\"distributed systems why and how permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Distributed Systems: Why and How</h1>\n<p>A distributed system is a cluster of networked computers working collectively. Why would we want distributed systems? One answer is: if one computer needs 20 hours to do some computing, then 20 computers may complete the job in one hour. Another answer is: if we just have a copy of data on one computer, it may fail, and we’d like to store multiple copies of data on different computers. </p>\n<p>But achieving these goals isn’t easy. Without coordination, 20 computers may simply produce useless outputs which are a worse result than using a single computer. We want to achieve 3 essential goals when coordinating a cluster of computers:</p>\n<ul>\n<li>Performance: we’d like the performance to scale with the number of computers.</li>\n<li>Consistency: we’d like replicated data stored on different computers to stay consistent.</li>\n<li>Fault-tolerant: we’d like the system keeps to work when some computers fail or at least recover quickly.</li>\n</ul>\n<p>On the performance side, MapReduce is one of the earliest programming models for distributed systems that enable high performance. For now, Spark is a very popular general-purpose cluster-computing framework, meaning that it’s able to utilize a distributed system to achieve high performance without the need to write programs in a certain model like map-reduce. Performance won’t be the focus of this post, instead, I’ll focus on consistency and fault-tolerance in a distributed system.</p>\n<h1 id=\"fault-tolerance\" style=\"position:relative;\"><a href=\"#fault-tolerance\" aria-label=\"fault tolerance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fault-tolerance</h1>\n<p>Besides performance, one major reason to use a distributed system is to tolerate faults. If you only have one computer doing a job, what if it fails? You’ll have to restart again, and it may take a long time that is not acceptable. If you only have one computer storing some data, what if it fails? You’ll need to pray that someone can recover the computer. </p>\n<p>We’ll be able to tolerate these faults if we have several replicated servers. If the major server fails, we will be able to use another replica to continuing the service.</p>\n<p>Nevertheless, it’s not easy to replicate a machine. One straightforward method is to copy the entire state of one server and transfer it to other servers. However, this can be very challenging:\n(1) The state of the server is almost always constantly changing, and it is costly to transfer a large amount of data;\n(2) transfer via the network may be fragile and we can easily get some deprecated data, which means we need extra procedures to check data and potentially retry often.</p>\n<p>Suppose we have a database server witch supports simple to get and put requests, and we want replicas of the data on the server on other computers. Consider this approach: rather than transfer the data once for a while, we can let every replicated server to function as the master server. As long as they receive the same requests and carry out the same operations, we can assure the data is consistent across servers. This is the idea behind <strong>state machine replication</strong>.</p>\n<p>Now we can give a general description of a fault-tolerant service using state machine replication. A client starts a request and sends the request to the master server, the master server distributes the request to other replicated servers and wait for their acknowledgments, and the master server replies to the client once the master server gets enough acknowledgments. Note that here we don’t let the client send requests to all the servers, but let the master server distribute the request so that the underlying distributed implementation is abstracted from the client.</p>\n<p>This general approach has many loopholes that demand further details. To proceed, we should see what kind of faults we need to deal with:</p>\n<ol>\n<li>\n<p>Some server may fail completely:</p>\n<p>a. If the master server fails, and exactly one replicated server needs to realize that and step up as the master. Furthermore, when the original master recovers,  we need to update it to the current state.</p>\n<p>b. If a replicated server fails, we need to update it to the current state</p>\n</li>\n<li>\n<p>The network connection may fail:</p>\n<p>a. The client’s network fails so that it cannot connect to the servers, but we don’t need to deal with this situation</p>\n<p>b. If the network fails and the master cannot connect some of the servers, we need to define the behaviors of the unconnected follower servers: should they wait or should one of them become the master? In the latter case, we will have two disconnected master, which gives rise to the <strong>split-brain</strong> problem.</p>\n</li>\n</ol>\n<h1 id=\"raft\" style=\"position:relative;\"><a href=\"#raft\" aria-label=\"raft permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Raft</h1>\n<p>We will focus on a specific algorithm that can provide fault-tolerant service for distributed systems, Raft. It is referred to as a consensus algorithm under a non-Byzantine scenario, which kind of means that there is no malicious server that tries to fool others and that we need to only deal with above non-malicious faults. Why consensus is relevant to building a fault-tolerant distributed system? Remember that we are using <strong>state machine replication</strong> approach to replicate our servers, so essentially we need to transfer the <strong>set of operations</strong> each server needs to apply to their states. The servers need to achieve consensus on the <strong>set of operations</strong>. It can be the set of requests from the clients, and it can be a set of any formats of commands.</p>\n<p>The central idea of Raft is rather “democratic.” The valid <strong>set of operations</strong> is defined by a leader (master server) elected by a majority of the servers. The leader will be re-elected if the current leader fails. In general, Raft follows the procedure below:</p>\n<ul>\n<li>\n<p>A leader (the master server) is elected if it receives a majority of votes among all servers.</p>\n<ul>\n<li>Each leader has an associated <strong>term number</strong> which increases monotonically for each new leader.</li>\n<li>A request from a client that contains an operation is sent only to the leader, and the leader distributes operations along with its <strong>term number</strong> to all the servers.</li>\n<li>When a majority of servers acknowledge the new operation, the leader applies the operation; it also updates its <strong>commit index</strong> which represents the last operation it has applied.</li>\n<li>The leader periodically sends our a <strong>heartbeat</strong> message to continue its leadership. The heartbeat message also contains information including the <strong>term number</strong> and its <strong>commit index</strong> for the followers to update their states.</li>\n</ul>\n</li>\n<li>\n<p>Each server keeps a list of entries called <strong>log</strong>, each entry containing an operation, and the <strong>term number</strong> when the entry is inserted.</p>\n<ul>\n<li>Each server has a timer with a which will be trigger within a random duration. Once the timer triggers, it runs for an election and asks other servers for votes.</li>\n<li>\n<p>Whenever a server receives a message from another server (it may be a new entry, a heartbeat, or a request for vote), if the <strong>term number</strong> of the sender is at least as high as itself, it resets the timer. It also updates its <strong>term number</strong> if the sender of the message has a higher <strong>term number</strong>.</p>\n<ul>\n<li>\n<p>If the request is a request for a vote, it grants the vote as long as:</p>\n<ol>\n<li>the candidate has the same <strong>term number</strong>;</li>\n<li>the candidate’s <strong>log</strong> is at least as long as the local <strong>log</strong>;</li>\n<li>the server has not voted for another candidate.</li>\n</ol>\n</li>\n<li>\n<p>If the request is to append new entries (sent from a leader):</p>\n<ul>\n<li>If <strong>commit index</strong> of the leader is higher than local <strong>commit index</strong>, update <strong>commit index</strong> and apply for all the entries before <strong>commit index</strong>.</li>\n<li>If the server finds conflicts between the leader’s <strong>log</strong> and its <strong>log</strong>, it replies to the leader and it will ultimately update its <strong>log</strong> to the leader’s <strong>log</strong>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>There are many more details and small discrepancies involved in the procedure, and you should check out the paper for the most accurate description. Here are more observations for a better understanding of the concepts involved:</p>\n<ul>\n<li><strong>term number</strong> can be understood as the version of a server, and it cannot become the leader if its version is outdated. This prevents a server that is disconnected for a while to mass-up other servers.</li>\n<li><strong>log</strong> can be understood as a list of operations. Our goal is to keep the log consistent across all the servers so that any server can apply each operation following the sequence of the log and arrive at the same state. Inserting an operation into the log and actually applying an operation are separated events.</li>\n<li><strong>commit index</strong> decides to which point in the log operation is applied (committed). It is assumed that an applied operation cannot be revoked. Therefore, it’s unsafe to apply an operation as soon as it is inserted since other servers never get the operation due to some failures.</li>\n<li><strong>heartbeat</strong> is sent only by the leader (at least according to itself) to tell other servers that it is still alive. This enables other servers to detect failures of the leader and to run for election.</li>\n</ul>\n<p>Now let’s make some key observations about how will Raft performs in response to the faults we lay down previously.</p>\n<p><strong>1a. The leader fails completely.</strong></p>\n<p>(1) If the client who sends very last entry before the leader fails to get an acknowledgment:</p>\n<p>This means that a majority of the servers have received the new entry from the leader, otherwise the leader will not send back the acknowledgment. The servers who have not received the new entry cannot win an election, because the majority of the servers have a more complete log and will not vote for them. Therefore, a server that has received the last entry will win the election and the log kept consistent with what clients will expect. The new leader will update the outdated servers (including the previous leader when it becomes alive).</p>\n<p>(2) If the client who sends very last entry before the leader fails does not get an acknowledgment:</p>\n<p>The behavior can vary. A server that hasn’t got the new entry may be elected. In that case, the client will treat this as a failed request and retry.</p>\n<p><strong>1b. Some replicated servers fail completely.</strong></p>\n<p>The leader will keep them updated when they come back alive.</p>\n<p><strong>2b. Network fails and the master cannot connect some of the servers.</strong></p>\n<p>If the unconnected servers are a minority, they will simply stay unchanged until they reconnect to the leader since none of them can be elected.</p>\n<p>If the unconnected servers are a majority, they will elect a new leader, and we will have the serious problem of <strong>split-brain</strong>. In effect, we now have two leaders and two disconnected clusters, each able to receive requests from different clients. Luckily, the previous leader along with its followers, Cluster A, will never apply any operations or reply to a client’s request since they are a minority, and the new leader along with its followers, Cluster B, will apply operations instead. When they reconnect, the previous leader will step down because it has a lower <strong>term number</strong>, and Cluster A will be synced according to Cluster B.</p>\n<p>There are many trickier failures that I haven’t discussed, but are solved by Raft.</p>\n<h1 id=\"a-framework-of-distributed-service-using-raft\" style=\"position:relative;\"><a href=\"#a-framework-of-distributed-service-using-raft\" aria-label=\"a framework of distributed service using raft permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A framework of distributed service using Raft</h1>\n<p>Raft provides us a firm algorithm to achieve consensus about the <em>set of operations</em>, and we can now describe a framework to build a service on top of Raft.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5534c814be090bb44b9be09b627acdf3/dc896/Raft.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.02702702702703%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHuzpIxh//EABYQAQEBAAAAAAAAAAAAAAAAABEQAP/aAAgBAQABBQJzSf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAAgQf/aAAgBAQAGPwIq/wD/xAAaEAACAwEBAAAAAAAAAAAAAAAAASFBgREx/9oACAEBAAE/IWnhKwtGoOrZp//aAAwDAQACAAMAAAAQEw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEBAQADAAMAAAAAAAAAAAABEQAhMVFBcYH/2gAIAQEAAT8Q9yvhgQDN+SGicK+9RHVywFQeoYGc1+b/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Distributed Service using Raft\"\n        title=\"Distributed Service using Raft\"\n        src=\"/static/5534c814be090bb44b9be09b627acdf3/1c72d/Raft.jpg\"\n        srcset=\"/static/5534c814be090bb44b9be09b627acdf3/a80bd/Raft.jpg 148w,\n/static/5534c814be090bb44b9be09b627acdf3/1c91a/Raft.jpg 295w,\n/static/5534c814be090bb44b9be09b627acdf3/1c72d/Raft.jpg 590w,\n/static/5534c814be090bb44b9be09b627acdf3/a8a14/Raft.jpg 885w,\n/static/5534c814be090bb44b9be09b627acdf3/fbd2c/Raft.jpg 1180w,\n/static/5534c814be090bb44b9be09b627acdf3/dc896/Raft.jpg 1294w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<em>Figure 1. Distributed Service using Raft.</em></p>\n<p>The idea is as follows:</p>\n<ul>\n<li>\n<p>The service is provided by a cluster of Servers:</p>\n<ul>\n<li>Each Server has an associated Raft</li>\n<li>Servers don’t communicate with each other, but Rafts communicate constantly to reach consensus</li>\n<li>The leader among Servers associated with the leader among Rafts.</li>\n<li>A Server and its Raft communicates through a <strong>apply channel</strong>. When an entry is committed at Raft, the Raft sends a message via <strong>apply channel</strong>.</li>\n</ul>\n</li>\n<li>Clients contact all Servers, but only send requests to the leader.</li>\n<li>\n<p>Upon a request:</p>\n<ul>\n<li>The Client sends the request to the leader Server.</li>\n<li>The leader Server tags the request with a <strong>request ID</strong>, and sends an entry consisting of necessary operations for the request along with a unique <strong>request ID</strong> to its Raft. It also creates a channel associated with <strong>request ID</strong> and waits for a response.</li>\n<li>The leader Raft receives the entry and distributes it to other Rafts, waiting for a majority acknowledgment, and then applies via <strong>apply channel</strong>.</li>\n<li>Servers constantly listening to <strong>apply channel</strong>, and when a new apply message comes, they perform the operations. If there is an opening channel associated with <strong>request ID</strong> (meaning that a client is waiting for a response), it sends an acknowledgment through the channel.</li>\n<li>The leader Server receives the acknowledgment via the channel associated with <strong>request ID</strong> and responds to the client.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h1>\n<p>[1] Ongaro, Diego, and Ousterhout, John. In Search of an Understandable Consensus Algorithm (Extended Version).</p>","frontmatter":{"title":"A Fault-Tolerant Distributed System with Raft","date":"July 16, 2020","description":"This post lays down the motivations and challenges for distributed systems and introduces an approach to fault-tolerant distributed systems using Raft."}}},"pageContext":{"slug":"/distributed-system/2020-7-16-distributed-system-raft/","previous":null,"next":{"fields":{"collection":"distributed-system","slug":"/distributed-system/2020-7-18-big-data-message-system/"},"frontmatter":{"title":"Big Data Message System"}}}},"staticQueryHashes":["3589320610","3966865564"]}